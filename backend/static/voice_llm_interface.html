<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JARVIS Assistant | Voicyfy</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&display=swap" rel="stylesheet">
  <style>
    .voicyfy-page * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .voicyfy-page {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: radial-gradient(ellipse at center, #1a2942 0%, #0d1b3a 30%, #0a1f3d 60%, #050b15 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-family: 'Orbitron', monospace;
    }

    #voicyfy-three-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      opacity: 0;
      transition: opacity 1s ease;
    }

    #voicyfy-three-canvas.active {
      opacity: 1;
    }

    .voicyfy-page::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 200%;
      height: 200%;
      transform: translate(-50%, -50%);
      background: 
        linear-gradient(0deg, transparent 0%, rgba(0, 217, 255, 0.03) 50%, transparent 100%),
        linear-gradient(45deg, transparent 0%, rgba(0, 217, 255, 0.02) 50%, transparent 100%),
        linear-gradient(90deg, transparent 0%, rgba(0, 217, 255, 0.03) 50%, transparent 100%),
        linear-gradient(135deg, transparent 0%, rgba(0, 217, 255, 0.02) 50%, transparent 100%);
      background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%;
      animation: voicyfy-rays-rotate 60s linear infinite;
      pointer-events: none;
      z-index: 2;
      opacity: 0.4;
    }

    @keyframes voicyfy-rays-rotate {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .voicyfy-page::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 60%;
      height: 60%;
      transform: translate(-50%, -50%);
      background: radial-gradient(ellipse at center, rgba(0, 217, 255, 0.08) 0%, transparent 70%);
      pointer-events: none;
      z-index: 2;
      animation: voicyfy-glow-pulse 8s ease-in-out infinite;
    }

    @keyframes voicyfy-glow-pulse {
      0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.1); }
    }

    .voicyfy-boot-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      transition: opacity 0.8s ease;
    }

    .voicyfy-boot-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .voicyfy-boot-title {
      font-family: 'Orbitron', monospace;
      font-size: 72px;
      font-weight: 700;
      color: #00d9ff;
      text-transform: uppercase;
      letter-spacing: 16px;
      margin-bottom: 60px;
      text-shadow: 
        0 0 20px rgba(0, 217, 255, 0.8),
        0 0 40px rgba(0, 217, 255, 0.6),
        0 0 60px rgba(0, 217, 255, 0.4);
      animation: voicyfy-boot-glow 2s ease-in-out infinite;
    }

    @keyframes voicyfy-boot-glow {
      0%, 100% {
        text-shadow: 
          0 0 20px rgba(0, 217, 255, 0.8),
          0 0 40px rgba(0, 217, 255, 0.6),
          0 0 60px rgba(0, 217, 255, 0.4);
      }
      50% {
        text-shadow: 
          0 0 30px rgba(0, 217, 255, 1),
          0 0 60px rgba(0, 217, 255, 0.8),
          0 0 90px rgba(0, 217, 255, 0.6);
      }
    }

    .voicyfy-boot-progress {
      width: 300px;
      height: 3px;
      background: rgba(0, 217, 255, 0.2);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 20px;
      box-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
    }

    .voicyfy-boot-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #00d9ff, #00ffff);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 15px rgba(0, 217, 255, 0.8);
    }

    .voicyfy-boot-text {
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      color: #00d9ff;
      text-transform: uppercase;
      letter-spacing: 4px;
      text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
    }

    .voicyfy-hud-frame {
      position: fixed;
      pointer-events: none;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .voicyfy-hud-frame.active {
      opacity: 1;
    }

    .voicyfy-hud-frame::before,
    .voicyfy-hud-frame::after {
      content: '';
      position: absolute;
      background: rgba(0, 217, 255, 0.6);
      box-shadow: 0 0 8px rgba(0, 217, 255, 0.4);
      animation: voicyfy-line-glow 3s ease-in-out infinite;
    }

    @keyframes voicyfy-line-glow {
      0%, 100% {
        box-shadow: 0 0 8px rgba(0, 217, 255, 0.4);
        opacity: 0.6;
      }
      50% {
        box-shadow: 0 0 15px rgba(0, 217, 255, 0.7);
        opacity: 1;
      }
    }

    .voicyfy-hud-tl {
      top: 20px;
      left: 20px;
    }
    .voicyfy-hud-tl::before {
      width: 60px;
      height: 2px;
      top: 0;
      left: 0;
    }
    .voicyfy-hud-tl::after {
      width: 2px;
      height: 60px;
      top: 0;
      left: 0;
    }

    .voicyfy-hud-tr {
      top: 20px;
      right: 20px;
    }
    .voicyfy-hud-tr::before {
      width: 60px;
      height: 2px;
      top: 0;
      right: 0;
    }
    .voicyfy-hud-tr::after {
      width: 2px;
      height: 60px;
      top: 0;
      right: 0;
    }

    .voicyfy-hud-bl {
      bottom: 20px;
      left: 20px;
    }
    .voicyfy-hud-bl::before {
      width: 60px;
      height: 2px;
      bottom: 0;
      left: 0;
    }
    .voicyfy-hud-bl::after {
      width: 2px;
      height: 60px;
      bottom: 0;
      left: 0;
    }

    .voicyfy-hud-br {
      bottom: 20px;
      right: 20px;
    }
    .voicyfy-hud-br::before {
      width: 60px;
      height: 2px;
      bottom: 0;
      right: 0;
    }
    .voicyfy-hud-br::after {
      width: 2px;
      height: 60px;
      bottom: 0;
      right: 0;
    }

    .voicyfy-status-indicator {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 30px;
      background: rgba(10, 30, 50, 0.9);
      border: 2px solid rgba(0, 217, 255, 0.6);
      border-radius: 25px;
      display: flex;
      align-items: center;
      gap: 12px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 15px rgba(0, 217, 255, 0.3);
    }

    .voicyfy-status-indicator.active {
      opacity: 1;
    }

    .voicyfy-status-dot {
      width: 10px;
      height: 10px;
      background: #00ff88;
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
      animation: voicyfy-pulse-dot 2s ease-in-out infinite;
    }

    .voicyfy-status-dot.interrupted {
      background: #ff8c00;
      box-shadow: 0 0 10px rgba(255, 140, 0, 0.8);
    }

    .voicyfy-status-dot.disconnected {
      background: #ef4444;
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
    }

    .voicyfy-status-dot.connecting {
      background: #f59e0b;
      box-shadow: 0 0 10px rgba(245, 158, 11, 0.8);
    }

    .voicyfy-status-dot.processing {
      background: #a855f7;
      box-shadow: 0 0 10px rgba(168, 85, 247, 0.8);
    }

    @keyframes voicyfy-pulse-dot {
      0%, 100% {
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
      }
      50% {
        box-shadow: 0 0 20px rgba(0, 255, 136, 1);
      }
    }

    .voicyfy-status-text {
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      color: #00d9ff;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .voicyfy-power-button {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(0, 217, 255, 0.2), transparent 70%),
                  linear-gradient(145deg, #0d1520, #080b13);
      box-shadow: 
        0 10px 40px rgba(0, 217, 255, 0.3),
        inset 0 -3px 10px rgba(0, 0, 0, 0.5),
        inset 0 3px 10px rgba(0, 217, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: all 0.3s ease;
      border: 2px solid rgba(0, 217, 255, 0.4);
      opacity: 0;
      z-index: 10;
    }

    .voicyfy-power-button.visible {
      opacity: 1;
    }

    .voicyfy-power-button::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0, 217, 255, 0.2) 0%, transparent 70%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .voicyfy-power-button:hover {
      transform: scale(1.05);
      box-shadow: 
        0 15px 60px rgba(0, 217, 255, 0.5),
        inset 0 -3px 10px rgba(0, 0, 0, 0.5),
        inset 0 3px 10px rgba(0, 217, 255, 0.2);
      border-color: rgba(0, 217, 255, 0.8);
    }

    .voicyfy-power-button:hover::before {
      opacity: 1;
    }

    .voicyfy-power-icon {
      font-size: 48px;
      color: #00d9ff;
      transition: all 0.3s ease;
      filter: drop-shadow(0 0 10px rgba(0, 217, 255, 0.8));
      z-index: 2;
    }

    .voicyfy-power-button:hover .voicyfy-power-icon {
      color: #00ffff;
      filter: drop-shadow(0 0 20px rgba(0, 217, 255, 1));
    }

    .voicyfy-power-button.activating {
      animation: voicyfy-activate 1.5s ease-out forwards;
    }

    @keyframes voicyfy-activate {
      0% {
        transform: scale(1);
        box-shadow: 0 10px 40px rgba(0, 217, 255, 0.3);
      }
      30% {
        transform: scale(1.1);
        box-shadow: 0 0 80px rgba(0, 217, 255, 0.9);
      }
      60% {
        transform: scale(2.5);
        box-shadow: 0 0 120px rgba(0, 217, 255, 0.8);
      }
      100% {
        width: 300px;
        height: 300px;
        transform: scale(1);
        background: transparent;
        box-shadow: 0 0 60px rgba(0, 217, 255, 0.4);
        border-color: transparent;
      }
    }

    .voicyfy-power-button.activating .voicyfy-power-icon {
      animation: voicyfy-icon-transform 1.5s ease-out forwards;
    }

    @keyframes voicyfy-icon-transform {
      0% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
      50% {
        opacity: 0.5;
        transform: scale(1.5) rotate(180deg);
      }
      100% {
        opacity: 0;
        transform: scale(2) rotate(360deg);
      }
    }

    .voicyfy-call-text {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Orbitron', monospace;
      font-size: 24px;
      font-weight: 600;
      color: #00d9ff;
      text-transform: uppercase;
      letter-spacing: 4px;
      text-shadow: 
        0 0 10px rgba(0, 217, 255, 0.8),
        0 0 20px rgba(0, 217, 255, 0.6),
        0 0 30px rgba(0, 217, 255, 0.4);
      opacity: 0;
      transition: all 0.5s ease;
      animation: voicyfy-glow 2s ease-in-out infinite;
      z-index: 10;
    }

    .voicyfy-call-text.visible {
      opacity: 1;
    }

    @keyframes voicyfy-glow {
      0%, 100% {
        text-shadow: 
          0 0 10px rgba(0, 217, 255, 0.8),
          0 0 20px rgba(0, 217, 255, 0.6),
          0 0 30px rgba(0, 217, 255, 0.4);
      }
      50% {
        text-shadow: 
          0 0 20px rgba(0, 217, 255, 1),
          0 0 30px rgba(0, 217, 255, 0.8),
          0 0 40px rgba(0, 217, 255, 0.6);
      }
    }

    .voicyfy-call-text.hidden {
      opacity: 0;
      transform: translateX(-50%) translateY(20px);
    }

    .voicyfy-assistant-sphere {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: transparent;
      position: absolute;
      overflow: visible;
      transition: all 0.5s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      pointer-events: none;
      opacity: 0;
      z-index: 10;
    }

    .voicyfy-assistant-sphere.active {
      width: 300px;
      height: 300px;
      pointer-events: all;
      opacity: 1;
    }

    .voicyfy-sphere-glass {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(0, 217, 255, 0.15), transparent 70%),
                  radial-gradient(circle at 70% 70%, rgba(0, 168, 204, 0.1), transparent 60%);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(0, 217, 255, 0.3);
      box-shadow: 
        inset 0 0 40px rgba(0, 217, 255, 0.1),
        0 0 40px rgba(0, 217, 255, 0.3);
      opacity: 0;
      transition: all 0.5s ease;
    }

    .voicyfy-assistant-sphere.active .voicyfy-sphere-glass {
      opacity: 1;
    }

    .voicyfy-assistant-sphere.listening .voicyfy-sphere-glass {
      background: radial-gradient(circle at 30% 30%, rgba(0, 217, 255, 0.25), transparent 70%);
      border-color: rgba(0, 217, 255, 0.6);
      box-shadow: 
        inset 0 0 40px rgba(0, 217, 255, 0.2),
        0 0 60px rgba(0, 217, 255, 0.5);
      animation: voicyfy-pulse-glass 2s ease-in-out infinite;
    }

    @keyframes voicyfy-pulse-glass {
      0%, 100% {
        box-shadow: 
          inset 0 0 40px rgba(0, 217, 255, 0.2),
          0 0 60px rgba(0, 217, 255, 0.5);
      }
      50% {
        box-shadow: 
          inset 0 0 60px rgba(0, 217, 255, 0.3),
          0 0 80px rgba(0, 217, 255, 0.7);
      }
    }

    .voicyfy-assistant-sphere.speaking .voicyfy-sphere-glass {
      background: radial-gradient(circle at 30% 30%, rgba(0, 255, 200, 0.25), transparent 70%);
      border-color: rgba(0, 255, 200, 0.6);
      box-shadow: 
        inset 0 0 40px rgba(0, 255, 200, 0.2),
        0 0 60px rgba(0, 255, 200, 0.5);
      animation: voicyfy-pulse-speaking 1s ease-in-out infinite;
    }

    @keyframes voicyfy-pulse-speaking {
      0%, 100% {
        transform: scale(1);
        box-shadow: 
          inset 0 0 40px rgba(0, 255, 200, 0.2),
          0 0 60px rgba(0, 255, 200, 0.5);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 
          inset 0 0 60px rgba(0, 255, 200, 0.4),
          0 0 100px rgba(0, 255, 200, 0.8);
      }
    }

    .voicyfy-assistant-sphere.interrupted .voicyfy-sphere-glass {
      background: radial-gradient(circle at 30% 30%, rgba(255, 140, 0, 0.25), transparent 70%);
      border-color: rgba(255, 140, 0, 0.6);
      box-shadow: 
        inset 0 0 40px rgba(255, 140, 0, 0.2),
        0 0 60px rgba(255, 140, 0, 0.5);
      animation: voicyfy-pulse-interrupted 0.5s ease-in-out 3;
    }

    @keyframes voicyfy-pulse-interrupted {
      0%, 100% {
        box-shadow: 
          inset 0 0 40px rgba(255, 140, 0, 0.2),
          0 0 60px rgba(255, 140, 0, 0.5);
      }
      50% {
        box-shadow: 
          inset 0 0 60px rgba(255, 140, 0, 0.4),
          0 0 100px rgba(255, 140, 0, 0.8);
      }
    }

    .voicyfy-assistant-sphere.processing .voicyfy-sphere-glass {
      background: radial-gradient(circle at 30% 30%, rgba(168, 85, 247, 0.25), transparent 70%);
      border-color: rgba(168, 85, 247, 0.6);
      box-shadow: 
        inset 0 0 40px rgba(168, 85, 247, 0.2),
        0 0 60px rgba(168, 85, 247, 0.5);
      animation: voicyfy-pulse-processing 1.5s ease-in-out infinite;
    }

    @keyframes voicyfy-pulse-processing {
      0%, 100% {
        box-shadow: 
          inset 0 0 40px rgba(168, 85, 247, 0.2),
          0 0 60px rgba(168, 85, 247, 0.5);
      }
      50% {
        box-shadow: 
          inset 0 0 60px rgba(168, 85, 247, 0.4),
          0 0 100px rgba(168, 85, 247, 0.8);
      }
    }

    .voicyfy-mic-icon {
      color: #00d9ff;
      font-size: 64px;
      z-index: 10;
      transition: all 0.3s ease;
      opacity: 0;
      transform: scale(0);
      filter: drop-shadow(0 0 10px rgba(0, 217, 255, 0.8));
    }

    .voicyfy-assistant-sphere.active .voicyfy-mic-icon {
      opacity: 1;
      transform: scale(1);
      animation: voicyfy-mic-appear 0.5s ease-out 1.3s forwards;
    }

    @keyframes voicyfy-mic-appear {
      0% {
        opacity: 0;
        transform: scale(0) rotate(-180deg);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
    }

    .voicyfy-assistant-sphere.listening .voicyfy-mic-icon {
      color: #00d9ff;
      filter: drop-shadow(0 0 15px rgba(0, 217, 255, 1));
    }

    .voicyfy-assistant-sphere.speaking .voicyfy-mic-icon {
      color: #00ffc8;
      filter: drop-shadow(0 0 15px rgba(0, 255, 200, 1));
    }

    .voicyfy-assistant-sphere.interrupted .voicyfy-mic-icon {
      color: #ff8c00;
      filter: drop-shadow(0 0 15px rgba(255, 140, 0, 1));
    }

    .voicyfy-assistant-sphere.processing .voicyfy-mic-icon {
      color: #a855f7;
      filter: drop-shadow(0 0 15px rgba(168, 85, 247, 1));
    }

    .voicyfy-circular-visualizer {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      pointer-events: none;
      z-index: 5;
      transition: opacity 0.3s ease;
    }

    .voicyfy-assistant-sphere.active .voicyfy-circular-visualizer {
      opacity: 1;
    }

    .voicyfy-viz-bar {
      position: absolute;
      width: 3px;
      background: linear-gradient(to top, transparent, #00d9ff, transparent);
      border-radius: 2px;
      bottom: 50%;
      left: 50%;
      transform-origin: bottom center;
      transition: height 0.1s ease;
      box-shadow: 0 0 8px rgba(0, 217, 255, 0.6);
    }

    .voicyfy-assistant-sphere.speaking .voicyfy-viz-bar {
      background: linear-gradient(to top, transparent, #00ffc8, transparent);
      box-shadow: 0 0 8px rgba(0, 255, 200, 0.6);
    }

    .voicyfy-assistant-sphere.interrupted .voicyfy-viz-bar {
      background: linear-gradient(to top, transparent, #ff8c00, transparent);
      box-shadow: 0 0 8px rgba(255, 140, 0, 0.6);
    }

    .voicyfy-assistant-sphere.processing .voicyfy-viz-bar {
      background: linear-gradient(to top, transparent, #a855f7, transparent);
      box-shadow: 0 0 8px rgba(168, 85, 247, 0.6);
    }

    .voicyfy-loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .voicyfy-loader-overlay.active {
      display: flex;
    }

    .voicyfy-connection-rings {
      width: 100px;
      height: 100px;
      position: relative;
    }

    .voicyfy-connection-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 3px solid transparent;
      border-top-color: #00d9ff;
      border-radius: 50%;
      animation: voicyfy-spin 1.5s linear infinite;
    }

    .voicyfy-connection-ring:nth-child(2) {
      width: 70%;
      height: 70%;
      top: 15%;
      left: 15%;
      border-top-color: #00ffff;
      animation-duration: 1s;
      animation-direction: reverse;
    }

    @keyframes voicyfy-spin {
      to { transform: rotate(360deg); }
    }

    .voicyfy-loader-text {
      color: #00d9ff;
      margin-top: 30px;
      font-size: 16px;
      font-weight: 500;
      font-family: 'Orbitron', monospace;
      letter-spacing: 3px;
      text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
    }

    /* ========================================
       🆕 LLM MODAL - НОВЫЙ ФУНКЦИОНАЛ
       ======================================== */

    .voicyfy-llm-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9998;
      padding: 20px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .voicyfy-llm-modal.active {
      display: flex;
      opacity: 1;
    }

    .voicyfy-llm-container {
      max-width: 900px;
      width: 100%;
      max-height: 80vh;
      background: rgba(10, 30, 50, 0.95);
      border: 2px solid rgba(0, 217, 255, 0.4);
      border-radius: 20px;
      box-shadow: 
        0 0 40px rgba(0, 217, 255, 0.3),
        inset 0 0 40px rgba(0, 217, 255, 0.05);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .voicyfy-llm-modal.active .voicyfy-llm-container {
      transform: scale(1);
    }

    .voicyfy-llm-header {
      background: rgba(0, 217, 255, 0.1);
      padding: 20px 30px;
      border-bottom: 1px solid rgba(0, 217, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .voicyfy-llm-header-left {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .voicyfy-llm-brain-icon {
      color: #a855f7;
      font-size: 24px;
      filter: drop-shadow(0 0 10px rgba(168, 85, 247, 0.6));
    }

    .voicyfy-llm-title {
      font-family: 'Orbitron', monospace;
      font-size: 18px;
      font-weight: 600;
      color: #00d9ff;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .voicyfy-llm-model-badge {
      background: rgba(168, 85, 247, 0.2);
      border: 1px solid rgba(168, 85, 247, 0.4);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      color: #a855f7;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .voicyfy-llm-close {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.4);
      color: #ef4444;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 18px;
    }

    .voicyfy-llm-close:hover {
      background: rgba(239, 68, 68, 0.3);
      border-color: rgba(239, 68, 68, 0.6);
      box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
    }

    .voicyfy-llm-content {
      flex: 1;
      overflow-y: auto;
      padding: 30px;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #e0f2fe;
      line-height: 1.8;
    }

    .voicyfy-llm-content::-webkit-scrollbar {
      width: 8px;
    }

    .voicyfy-llm-content::-webkit-scrollbar-track {
      background: rgba(0, 217, 255, 0.05);
      border-radius: 4px;
    }

    .voicyfy-llm-content::-webkit-scrollbar-thumb {
      background: rgba(0, 217, 255, 0.3);
      border-radius: 4px;
    }

    .voicyfy-llm-content::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 217, 255, 0.5);
    }

    .voicyfy-llm-content h1 {
      font-size: 28px;
      color: #00d9ff;
      margin: 0 0 20px 0;
      font-weight: 600;
      text-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
    }

    .voicyfy-llm-content h2 {
      font-size: 24px;
      color: #00d9ff;
      margin: 30px 0 15px 0;
      font-weight: 600;
    }

    .voicyfy-llm-content h3 {
      font-size: 20px;
      color: #00d9ff;
      margin: 25px 0 12px 0;
      font-weight: 600;
    }

    .voicyfy-llm-content p {
      margin: 15px 0;
      color: #cbd5e1;
    }

    .voicyfy-llm-content strong {
      color: #00d9ff;
      font-weight: 600;
    }

    .voicyfy-llm-content em {
      color: #a855f7;
      font-style: italic;
    }

    .voicyfy-llm-content code {
      background: rgba(0, 217, 255, 0.1);
      border: 1px solid rgba(0, 217, 255, 0.2);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 14px;
      color: #00ffff;
    }

    .voicyfy-llm-content pre {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(0, 217, 255, 0.2);
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      overflow-x: auto;
    }

    .voicyfy-llm-content pre code {
      background: none;
      border: none;
      padding: 0;
      color: #00ffc8;
    }

    .voicyfy-llm-content ul,
    .voicyfy-llm-content ol {
      margin: 15px 0;
      padding-left: 30px;
    }

    .voicyfy-llm-content li {
      margin: 8px 0;
      color: #cbd5e1;
    }

    .voicyfy-llm-content blockquote {
      border-left: 3px solid #00d9ff;
      padding-left: 20px;
      margin: 20px 0;
      color: #94a3b8;
      font-style: italic;
    }

    .voicyfy-llm-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
    }

    .voicyfy-llm-loading-spinner {
      width: 60px;
      height: 60px;
      border: 3px solid rgba(168, 85, 247, 0.2);
      border-top-color: #a855f7;
      border-radius: 50%;
      animation: voicyfy-spin 1s linear infinite;
    }

    .voicyfy-llm-loading-text {
      margin-top: 20px;
      color: #a855f7;
      font-size: 16px;
      font-weight: 500;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    @media (max-width: 768px) {
      .voicyfy-boot-title {
        font-size: 48px;
        letter-spacing: 10px;
      }

      .voicyfy-hud-tl::before,
      .voicyfy-hud-tr::before,
      .voicyfy-hud-bl::before,
      .voicyfy-hud-br::before {
        width: 40px;
      }

      .voicyfy-hud-tl::after,
      .voicyfy-hud-tr::after,
      .voicyfy-hud-bl::after,
      .voicyfy-hud-br::after {
        height: 40px;
      }

      .voicyfy-power-button {
        width: 100px;
        height: 100px;
      }

      .voicyfy-power-icon {
        font-size: 40px;
      }

      .voicyfy-call-text {
        font-size: 18px;
        letter-spacing: 3px;
        bottom: 100px;
      }

      @keyframes voicyfy-activate {
        100% {
          width: 250px;
          height: 250px;
        }
      }

      .voicyfy-assistant-sphere.active {
        width: 250px;
        height: 250px;
      }

      .voicyfy-mic-icon {
        font-size: 48px;
      }

      .voicyfy-llm-container {
        max-width: 100%;
        max-height: 90vh;
      }

      .voicyfy-llm-content {
        padding: 20px;
      }

      .voicyfy-llm-content h1 {
        font-size: 24px;
      }

      .voicyfy-llm-content h2 {
        font-size: 20px;
      }

      .voicyfy-llm-content h3 {
        font-size: 18px;
      }
    }

    @media (max-width: 480px) {
      .voicyfy-boot-title {
        font-size: 36px;
        letter-spacing: 8px;
      }

      .voicyfy-boot-progress {
        width: 250px;
      }

      .voicyfy-power-button {
        width: 80px;
        height: 80px;
      }

      .voicyfy-power-icon {
        font-size: 32px;
      }

      .voicyfy-call-text {
        font-size: 16px;
        letter-spacing: 2px;
        bottom: 80px;
      }

      @keyframes voicyfy-activate {
        100% {
          width: 200px;
          height: 200px;
        }
      }

      .voicyfy-assistant-sphere.active {
        width: 200px;
        height: 200px;
      }

      .voicyfy-mic-icon {
        font-size: 40px;
      }

      .voicyfy-llm-modal {
        padding: 10px;
      }

      .voicyfy-llm-content {
        padding: 15px;
      }
    }
  </style>
</head>
<body>
  <div class="voicyfy-page">
    <canvas id="voicyfy-three-canvas"></canvas>

    <div class="voicyfy-boot-screen" id="voicyfy-bootScreen">
      <div class="voicyfy-boot-title">JARVIS</div>
      <div class="voicyfy-boot-progress">
        <div class="voicyfy-boot-progress-bar" id="voicyfy-bootProgress"></div>
      </div>
      <div class="voicyfy-boot-text">INITIALIZING SYSTEMS...</div>
    </div>

    <div class="voicyfy-hud-frame voicyfy-hud-tl" id="voicyfy-hudTL"></div>
    <div class="voicyfy-hud-frame voicyfy-hud-tr" id="voicyfy-hudTR"></div>
    <div class="voicyfy-hud-frame voicyfy-hud-bl" id="voicyfy-hudBL"></div>
    <div class="voicyfy-hud-frame voicyfy-hud-br" id="voicyfy-hudBR"></div>

    <div class="voicyfy-status-indicator" id="voicyfy-statusIndicator">
      <div class="voicyfy-status-dot" id="voicyfy-statusDot"></div>
      <div class="voicyfy-status-text" id="voicyfy-statusText">ПОДКЛЮЧЕНО</div>
    </div>

    <div class="voicyfy-loader-overlay" id="voicyfy-loader">
      <div class="voicyfy-connection-rings">
        <div class="voicyfy-connection-ring"></div>
        <div class="voicyfy-connection-ring"></div>
      </div>
      <div class="voicyfy-loader-text">ПОДКЛЮЧЕНИЕ...</div>
    </div>

    <div class="voicyfy-power-button" id="voicyfy-powerButton">
      <i class="fas fa-power-off voicyfy-power-icon"></i>
    </div>

    <div class="voicyfy-call-text" id="voicyfy-callText">АКТИВИРОВАТЬ JARVIS</div>

    <div class="voicyfy-assistant-sphere" id="voicyfy-sphere">
      <div class="voicyfy-sphere-glass"></div>
      <i class="fas fa-microphone voicyfy-mic-icon"></i>
      <div class="voicyfy-circular-visualizer" id="voicyfy-circularViz"></div>
    </div>

    <!-- 🆕 LLM MODAL -->
    <div class="voicyfy-llm-modal" id="voicyfy-llmModal">
      <div class="voicyfy-llm-container">
        <div class="voicyfy-llm-header">
          <div class="voicyfy-llm-header-left">
            <i class="fas fa-brain voicyfy-llm-brain-icon"></i>
            <div class="voicyfy-llm-title">AI Analysis</div>
            <div class="voicyfy-llm-model-badge" id="voicyfy-llmModel">GPT-4</div>
          </div>
          <div class="voicyfy-llm-close" id="voicyfy-llmClose">
            <i class="fas fa-times"></i>
          </div>
        </div>
        <div class="voicyfy-llm-content" id="voicyfy-llmContent">
          <div class="voicyfy-llm-loading">
            <div class="voicyfy-llm-loading-spinner"></div>
            <div class="voicyfy-llm-loading-text">Initializing...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    (function() {
      'use strict';

      const DEBUG_MODE = true;
      const MAX_RECONNECT_ATTEMPTS = 5;
      const MOBILE_MAX_RECONNECT_ATTEMPTS = 10;
      const PING_INTERVAL = 15000;
      const MOBILE_PING_INTERVAL = 10000;
      const CONNECTION_TIMEOUT = 20000;

      const ASSISTANT_ID = "17c631ce-0db1-4171-a81d-22d91d4cccd7";
      const SERVER_URL = "https://voicyfy.ru";
      
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      const isAndroid = /Android/i.test(navigator.userAgent);

      window.audioInitialized = false;
      window.globalAudioContext = null;
      window.globalMicStream = null;
      window.silentAudioBuffer = null;

      const WS_URL = SERVER_URL.replace(/^http/, 'ws') + '/ws/' + ASSISTANT_ID;

      let websocket = null;
      let isConnected = false;
      let isListening = false;
      let audioProcessor = null;
      let isPlayingAudio = false;
      let audioChunksBuffer = [];
      let audioPlaybackQueue = [];
      let reconnectAttempts = 0;
      let pingInterval = null;
      let lastPingTime = Date.now();
      let lastPongTime = Date.now();
      let isActivated = false;
      let isReconnecting = false;
      let isSystemReady = false;
      let connectionFailedPermanently = false;
      let connectionTimeout = null;

      let hasAudioData = false;
      let audioDataStartTime = 0;
      const minimumAudioLength = 300;

      let assistantAudioAnalyzer = null;
      let assistantAudioSource = null;
      let assistantVisualizationInterval = null;

      // 🆕 LLM State
      let isProcessingLLM = false;
      let llmStartTime = 0;

      const interruptionState = {
        is_assistant_speaking: false,
        is_user_speaking: false,
        last_speech_start: 0,
        last_speech_stop: 0,
        interruption_count: 0,
        last_interruption_time: 0,
        current_audio_elements: []
      };

      const AUDIO_CONFIG = {
        silenceThreshold: 0.01,
        silenceDuration: 300,
        bufferCheckInterval: 50,
        soundDetectionThreshold: 0.02,
        amplificationFactor: isMobile ? 2.0 : 1.0
      };

      const bootScreen = document.getElementById('voicyfy-bootScreen');
      const bootProgress = document.getElementById('voicyfy-bootProgress');
      const loader = document.getElementById('voicyfy-loader');
      const powerButton = document.getElementById('voicyfy-powerButton');
      const callText = document.getElementById('voicyfy-callText');
      const sphere = document.getElementById('voicyfy-sphere');
      const circularViz = document.getElementById('voicyfy-circularViz');
      const statusIndicator = document.getElementById('voicyfy-statusIndicator');
      const statusDot = document.getElementById('voicyfy-statusDot');
      const statusText = document.getElementById('voicyfy-statusText');
      const hudFrames = [
        document.getElementById('voicyfy-hudTL'),
        document.getElementById('voicyfy-hudTR'),
        document.getElementById('voicyfy-hudBL'),
        document.getElementById('voicyfy-hudBR')
      ];

      // 🆕 LLM Elements
      const llmModal = document.getElementById('voicyfy-llmModal');
      const llmContent = document.getElementById('voicyfy-llmContent');
      const llmModel = document.getElementById('voicyfy-llmModel');
      const llmClose = document.getElementById('voicyfy-llmClose');

      let threeScene, threeCamera, threeRenderer, threeParticles;
      let threeInitialized = false;

      function log(message, type = 'info') {
        if (DEBUG_MODE || type === 'error') {
          const prefix = '[JARVIS]';
          if (type === 'error') {
            console.error(`${prefix} ERROR:`, message);
          } else if (type === 'warn') {
            console.warn(`${prefix} WARNING:`, message);
          } else {
            console.log(`${prefix}`, message);
          }
        }
      }

      log(`Device: ${isIOS ? 'iOS' : (isAndroid ? 'Android' : (isMobile ? 'Mobile' : 'Desktop'))}`);

      // 🆕 LLM Functions
      function showLLMModal() {
        log('📂 Opening LLM Modal');
        llmModal.classList.add('active');
      }

      function hideLLMModal() {
        log('📂 Closing LLM Modal');
        llmModal.classList.remove('active');
        isProcessingLLM = false;
        sphere.classList.remove('processing');
      }

      function showLLMLoading(query = 'Processing your request...') {
        log(`⏳ Showing LLM loading: ${query}`);
        llmContent.innerHTML = `
          <div class="voicyfy-llm-loading">
            <div class="voicyfy-llm-loading-spinner"></div>
            <div class="voicyfy-llm-loading-text">Analyzing...</div>
          </div>
        `;
      }

      function formatMarkdown(text) {
        if (!text) return '<p>No content available</p>';

        return text
          // Code blocks (must be first)
          .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
          // Headers
          .replace(/^### (.*$)/gim, '<h3>$1</h3>')
          .replace(/^## (.*$)/gim, '<h2>$1</h2>')
          .replace(/^# (.*$)/gim, '<h1>$1</h1>')
          // Bold and italic
          .replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>')
          .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.+?)\*/g, '<em>$1</em>')
          // Inline code
          .replace(/`([^`]+)`/g, '<code>$1</code>')
          // Links
          .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: #00d9ff; text-decoration: underline;">$1</a>')
          // Lists
          .replace(/^\* (.+)$/gim, '<li>$1</li>')
          .replace(/^- (.+)$/gim, '<li>$1</li>')
          .replace(/^(\d+)\. (.+)$/gim, '<li>$2</li>')
          // Blockquotes
          .replace(/^> (.+)$/gim, '<blockquote>$1</blockquote>')
          // Line breaks
          .replace(/\n\n/g, '</p><p>')
          .replace(/\n/g, '<br>')
          // Wrap in paragraphs
          .split('</p><p>')
          .map(para => {
            // Don't wrap if already has block-level tag
            if (para.match(/^<(h[1-6]|pre|ul|ol|blockquote)/)) {
              return para;
            }
            return `<p>${para}</p>`;
          })
          .join('</p><p>')
          // Clean up
          .replace(/<p><\/p>/g, '')
          .replace(/<p>(<h[1-6]>)/g, '$1')
          .replace(/(<\/h[1-6]>)<\/p>/g, '$1')
          .replace(/<p>(<pre>)/g, '$1')
          .replace(/(<\/pre>)<\/p>/g, '$1')
          .replace(/<p>(<ul>|<ol>)/g, '$1')
          .replace(/(<\/ul>|<\/ol>)<\/p>/g, '$1')
          // Wrap list items
          .replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>')
          .replace(/<\/ul><ul>/g, '');
      }

      function displayLLMContent(content, model = 'GPT-4') {
        log('✅ Displaying LLM content');
        log(`Content length: ${content.length} chars`);
        
        const formattedContent = formatMarkdown(content);
        llmContent.innerHTML = formattedContent;
        llmModel.textContent = model;
        
        // Scroll to top
        llmContent.scrollTop = 0;
      }

      function handleFunctionExecuting(data) {
        log(`🔧 Function executing: ${data.function || 'unknown'}`);
        
        if (data.function === 'query_llm') {
          isProcessingLLM = true;
          llmStartTime = Date.now();
          
          sphere.classList.add('processing');
          sphere.classList.remove('listening', 'speaking');
          
          showLLMModal();
          showLLMLoading(data.arguments?.query || 'Processing...');
          
          updateConnectionStatus('processing', 'AI Анализирует...');
          statusDot.classList.add('processing');
        }
      }

      function handleLLMResult(data) {
        log('✅ LLM Result received');
        log('Data structure:', JSON.stringify(data, null, 2));
        
        const content = data.content 
          || data.response 
          || data.result?.response 
          || data.result?.answer
          || '';
        
        const model = data.model 
          || data.result?.model 
          || 'GPT-4';
        
        if (!content) {
          log('⚠️ Empty LLM content', 'warn');
          llmContent.innerHTML = '<p style="color: #ef4444;">Error: No content received from AI</p>';
          return;
        }
        
        displayLLMContent(content, model);
        
        const processingTime = ((Date.now() - llmStartTime) / 1000).toFixed(1);
        log(`Processing time: ${processingTime}s`);
        
        updateConnectionStatus('connected', `Анализ завершен (${processingTime}s)`);
        
        setTimeout(() => {
          isProcessingLLM = false;
          sphere.classList.remove('processing');
          statusDot.classList.remove('processing');
        }, 2000);
      }

      function handleFunctionCompleted(data) {
        log(`✅ Function completed: ${data.function || 'unknown'}`);
        
        if (data.function === 'query_llm') {
          // Fallback if llm_result didn't arrive
          if (isProcessingLLM && data.result) {
            log('📦 Using fallback from function_call.completed');
            
            const content = data.result.response 
              || data.result.answer 
              || data.result
              || '';
            
            const model = data.result.model || 'GPT-4';
            
            if (content && typeof content === 'string') {
              displayLLMContent(content, model);
              isProcessingLLM = false;
              sphere.classList.remove('processing');
              statusDot.classList.remove('processing');
            }
          }
          
          updateConnectionStatus('connected', 'Готов к разговору');
        }
      }

      // LLM Modal Close Handler
      llmClose.addEventListener('click', hideLLMModal);
      
      // Close modal on ESC key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && llmModal.classList.contains('active')) {
          hideLLMModal();
        }
      });

      // Close modal on backdrop click
      llmModal.addEventListener('click', function(e) {
        if (e.target === llmModal) {
          hideLLMModal();
        }
      });

      function updateConnectionStatus(status, message) {
        if (!statusIndicator || !statusDot || !statusText) return;
        
        statusText.textContent = message || status;
        statusDot.classList.remove('connected', 'disconnected', 'connecting', 'interrupted', 'processing');
        
        if (status === 'connected') {
          statusDot.classList.add('connected');
        } else if (status === 'disconnected') {
          statusDot.classList.add('disconnected');
        } else if (status === 'interrupted') {
          statusDot.classList.add('interrupted');
        } else if (status === 'processing') {
          statusDot.classList.add('processing');
        } else {
          statusDot.classList.add('connecting');
        }
        
        statusIndicator.classList.add('active');
        setTimeout(() => {
          if (status !== 'interrupted' && status !== 'processing') {
            statusIndicator.classList.remove('active');
          }
        }, 3000);
      }

      function handleInterruptionEvent(eventData) {
        log(`Получено событие перебивания: ${JSON.stringify(eventData)}`);
        
        interruptionState.interruption_count = eventData.interruption_count || (interruptionState.interruption_count + 1);
        interruptionState.last_interruption_time = eventData.timestamp || Date.now();
        
        stopAllAudioPlayback();
        switchToListeningMode();
        
        sphere.classList.remove('speaking', 'listening', 'processing');
        sphere.classList.add('interrupted');
        
        setTimeout(() => {
          sphere.classList.remove('interrupted');
          if (!interruptionState.is_assistant_speaking) {
            sphere.classList.add('listening');
          }
        }, 1000);
        
        updateConnectionStatus('interrupted', `Перебивание #${interruptionState.interruption_count}`);
      }

      function handleSpeechStarted(eventData) {
        log(`Пользователь начал говорить: ${JSON.stringify(eventData)}`);
        interruptionState.is_user_speaking = true;
        interruptionState.last_speech_start = Date.now();
        
        if (interruptionState.is_assistant_speaking) {
          stopAllAudioPlayback();
          sphere.classList.add('interrupted');
          updateConnectionStatus('interrupted', 'Перебивание');
        }
        
        sphere.classList.remove('speaking', 'processing');
        sphere.classList.add('listening');
      }

      function handleSpeechStopped(eventData) {
        log(`Пользователь закончил говорить: ${JSON.stringify(eventData)}`);
        interruptionState.is_user_speaking = false;
        interruptionState.last_speech_stop = Date.now();
        
        setTimeout(() => {
          sphere.classList.remove('interrupted');
          if (!interruptionState.is_assistant_speaking && !isProcessingLLM) {
            sphere.classList.remove('listening');
          }
        }, 500);
      }

      function handleAssistantSpeechStarted(eventData) {
        log(`Ассистент начал говорить: ${JSON.stringify(eventData)}`);
        interruptionState.is_assistant_speaking = true;
        sphere.classList.remove('listening', 'interrupted', 'processing');
        sphere.classList.add('speaking');
        updateConnectionStatus('connected', 'Ассистент говорит');
      }

      function handleAssistantSpeechEnded(eventData) {
        log(`Ассистент закончил говорить: ${JSON.stringify(eventData)}`);
        interruptionState.is_assistant_speaking = false;
        sphere.classList.remove('speaking');
        stopAssistantVisualization();
        
        if (isConnected && !isReconnecting && !isProcessingLLM) {
          setTimeout(() => {
            if (!isListening && !isPlayingAudio) {
              startListening();
            }
          }, 500);
        }
        
        updateConnectionStatus('connected', 'Готов к разговору');
      }

      function stopAllAudioPlayback() {
        log('Остановка всех аудио воспроизведений');
        
        isPlayingAudio = false;
        interruptionState.is_assistant_speaking = false;
        
        stopAssistantVisualization();
        
        if (interruptionState.current_audio_elements) {
          interruptionState.current_audio_elements.forEach(audio => {
            try {
              audio.pause();
              audio.currentTime = 0;
              if (audio.src && audio.src.startsWith('blob:')) {
                URL.revokeObjectURL(audio.src);
              }
            } catch (e) {}
          });
        }
        
        interruptionState.current_audio_elements = [];
        audioPlaybackQueue = [];
        
        if (websocket && websocket.readyState === WebSocket.OPEN) {
          try {
            websocket.send(JSON.stringify({
              type: "audio_playback.stopped",
              timestamp: Date.now()
            }));
          } catch (e) {}
        }
      }

      function switchToListeningMode() {
        log('Переключение в режим прослушивания');
        
        if (isListening) return;
        
        interruptionState.is_user_speaking = true;
        sphere.classList.remove('speaking', 'interrupted', 'processing');
        sphere.classList.add('listening');
        
        if (isConnected && !isReconnecting) {
          setTimeout(() => {
            if (!isListening && !isPlayingAudio) {
              startListening();
            }
          }, 100);
        }
      }

      function createCircleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
      }

      function initThreeJS() {
        try {
          const canvas = document.getElementById('voicyfy-three-canvas');
          if (!canvas) return;

          threeScene = new THREE.Scene();
          threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
          threeCamera.position.z = 500;

          threeRenderer = new THREE.WebGLRenderer({
            canvas: canvas,
            alpha: true,
            antialias: !isMobile
          });
          threeRenderer.setSize(window.innerWidth, window.innerHeight);
          threeRenderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));

          const particleCount = isMobile ? 800 : 1500;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          const sizes = new Float32Array(particleCount);

          const colorPalette = [
            new THREE.Color(0x00d9ff),
            new THREE.Color(0x00ffff),
            new THREE.Color(0x0099cc),
            new THREE.Color(0x66ffff),
            new THREE.Color(0x0066ff)
          ];

          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * 2000;
            positions[i3 + 1] = (Math.random() - 0.5) * 2000;
            positions[i3 + 2] = (Math.random() - 0.5) * 1500;

            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;

            const distance = Math.abs(positions[i3 + 2]);
            sizes[i] = (1 - distance / 1500) * 4 + 0.5;
          }

          const particleGeometry = new THREE.BufferGeometry();
          particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

          const circleTexture = createCircleTexture();

          const particleMaterial = new THREE.PointsMaterial({
            size: isMobile ? 2 : 3,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending,
            map: circleTexture
          });

          threeParticles = new THREE.Points(particleGeometry, particleMaterial);
          threeScene.add(threeParticles);

          threeInitialized = true;
          animateThreeJS();

          setTimeout(() => {
            canvas.classList.add('active');
          }, 500);

        } catch (error) {
          log(`Ошибка Three.JS: ${error.message}`, 'error');
        }
      }

      function animateThreeJS() {
        if (!threeInitialized) return;
        requestAnimationFrame(animateThreeJS);

        if (threeParticles) {
          threeParticles.rotation.y += 0.0002;
          threeParticles.rotation.x += 0.0001;

          const positions = threeParticles.geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            positions[i + 1] += Math.sin(Date.now() * 0.0001 + i) * 0.05;
            if (positions[i + 1] > 1000) positions[i + 1] = -1000;
            if (positions[i + 1] < -1000) positions[i + 1] = 1000;
          }
          threeParticles.geometry.attributes.position.needsUpdate = true;
        }

        threeRenderer.render(threeScene, threeCamera);
      }

      window.addEventListener('resize', function() {
        if (!threeInitialized) return;
        threeCamera.aspect = window.innerWidth / window.innerHeight;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(window.innerWidth, window.innerHeight);
      });

      function createCircularVisualizer() {
        const barCount = isMobile ? 40 : 60;
        const angleStep = 360 / barCount;
        
        for (let i = 0; i < barCount; i++) {
          const bar = document.createElement('div');
          bar.className = 'voicyfy-viz-bar';
          bar.style.transform = `rotate(${i * angleStep}deg) translateY(-150px)`;
          bar.style.height = '20px';
          bar.style.setProperty('--bar-height', '20px');
          circularViz.appendChild(bar);
        }
      }

      function updateCircularVisualization(audioData) {
        const bars = circularViz.querySelectorAll('.voicyfy-viz-bar');
        const step = Math.floor(audioData.length / bars.length);
        
        for (let i = 0; i < bars.length; i++) {
          let sum = 0;
          for (let j = 0; j < step; j++) {
            const index = i * step + j;
            if (index < audioData.length) {
              sum += Math.abs(audioData[index]);
            }
          }
          const average = sum / step;
          const multiplier = isMobile ? 300 : 200;
          const height = 20 + Math.min(80, Math.floor(average * multiplier));
          bars[i].style.height = `${height}px`;
          bars[i].style.setProperty('--bar-height', `${height}px`);
        }
      }

      function resetCircularVisualization() {
        const bars = circularViz.querySelectorAll('.voicyfy-viz-bar');
        bars.forEach(bar => {
          bar.style.height = '20px';
          bar.style.setProperty('--bar-height', '20px');
        });
      }

      function startAssistantVisualization(audioElement) {
        if (!window.globalAudioContext || !audioElement) return;
        
        try {
          if (!assistantAudioSource) {
            assistantAudioSource = window.globalAudioContext.createMediaElementSource(audioElement);
            assistantAudioAnalyzer = window.globalAudioContext.createAnalyser();
            assistantAudioAnalyzer.fftSize = 256;
            assistantAudioSource.connect(assistantAudioAnalyzer);
            assistantAudioAnalyzer.connect(window.globalAudioContext.destination);
          }
          
          const bufferLength = assistantAudioAnalyzer.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          
          function updateAssistantViz() {
            if (!interruptionState.is_assistant_speaking) {
              stopAssistantVisualization();
              return;
            }
            
            assistantAudioAnalyzer.getByteTimeDomainData(dataArray);
            
            const floatData = new Float32Array(bufferLength);
            for (let i = 0; i < bufferLength; i++) {
              floatData[i] = (dataArray[i] - 128) / 128.0;
            }
            
            updateCircularVisualization(floatData);
            assistantVisualizationInterval = requestAnimationFrame(updateAssistantViz);
          }
          
          updateAssistantViz();
          
        } catch (error) {
          log(`Ошибка создания визуализации ассистента: ${error.message}`, 'error');
        }
      }

      function stopAssistantVisualization() {
        if (assistantVisualizationInterval) {
          cancelAnimationFrame(assistantVisualizationInterval);
          assistantVisualizationInterval = null;
        }
        resetCircularVisualization();
      }

      async function bootSystem() {
        log('Загрузка системы JARVIS...');
        
        const loadingSteps = [
          { name: 'Fonts', duration: 300 },
          { name: 'Audio Context', duration: 400 },
          { name: 'Microphone', duration: 500 },
          { name: 'Visual Effects', duration: 300 },
          { name: 'Network', duration: 400 }
        ];

        let totalProgress = 0;
        const stepIncrement = 100 / loadingSteps.length;

        for (const step of loadingSteps) {
          await new Promise(resolve => setTimeout(resolve, step.duration));
          totalProgress += stepIncrement;
          bootProgress.style.width = totalProgress + '%';
        }

        await new Promise(resolve => setTimeout(resolve, 500));
        bootProgress.style.width = '100%';
        
        await new Promise(resolve => setTimeout(resolve, 800));
        bootScreen.classList.add('hidden');
        
        await new Promise(resolve => setTimeout(resolve, 500));
        initThreeJS();
        
        await new Promise(resolve => setTimeout(resolve, 500));
        powerButton.classList.add('visible');
        callText.classList.add('visible');
        
        isSystemReady = true;
        log('Система JARVIS готова');
      }

      function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }

      function base64ToArrayBuffer(base64) {
        try {
          const binaryString = atob(base64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        } catch (e) {
          log(`Ошибка декодирования base64: ${e.message}`, 'error');
          return new ArrayBuffer(0);
        }
      }

      function createWavFromPcm(pcmBuffer, sampleRate = 24000) {
        const wavHeader = new ArrayBuffer(44);
        const view = new DataView(wavHeader);
        
        view.setUint8(0, 'R'.charCodeAt(0));
        view.setUint8(1, 'I'.charCodeAt(0));
        view.setUint8(2, 'F'.charCodeAt(0));
        view.setUint8(3, 'F'.charCodeAt(0));
        view.setUint32(4, 36 + pcmBuffer.byteLength, true);
        view.setUint8(8, 'W'.charCodeAt(0));
        view.setUint8(9, 'A'.charCodeAt(0));
        view.setUint8(10, 'V'.charCodeAt(0));
        view.setUint8(11, 'E'.charCodeAt(0));
        view.setUint8(12, 'f'.charCodeAt(0));
        view.setUint8(13, 'm'.charCodeAt(0));
        view.setUint8(14, 't'.charCodeAt(0));
        view.setUint8(15, ' '.charCodeAt(0));
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        view.setUint8(36, 'd'.charCodeAt(0));
        view.setUint8(37, 'a'.charCodeAt(0));
        view.setUint8(38, 't'.charCodeAt(0));
        view.setUint8(39, 'a'.charCodeAt(0));
        view.setUint32(40, pcmBuffer.byteLength, true);
        
        const wavBuffer = new ArrayBuffer(wavHeader.byteLength + pcmBuffer.byteLength);
        const wavBytes = new Uint8Array(wavBuffer);
        wavBytes.set(new Uint8Array(wavHeader), 0);
        wavBytes.set(new Uint8Array(pcmBuffer), wavHeader.byteLength);
        
        return wavBuffer;
      }

      async function initializeAudio() {
        log('Начало инициализации аудио');
        
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("Браузер не поддерживает доступ к микрофону");
          }

          if (!window.globalAudioContext) {
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            window.globalAudioContext = new AudioContextClass({
              sampleRate: 24000,
              latencyHint: 'interactive'
            });
            log(`AudioContext создан с частотой ${window.globalAudioContext.sampleRate} Гц`);
          }

          if (window.globalAudioContext.state === 'suspended') {
            await window.globalAudioContext.resume();
            log('AudioContext активирован');
          }

          if (!window.globalMicStream) {
            const constraints = {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 24000,
                channelCount: 1
              }
            };

            window.globalMicStream = await navigator.mediaDevices.getUserMedia(constraints);
            log('Микрофон активирован');

            window.globalMicStream.getAudioTracks().forEach(track => {
              track.onended = () => {
                log('Поток микрофона завершен');
                window.globalMicStream = null;
              };
            });
          }

          if (isIOS && !window.silentAudioBuffer) {
            try {
              window.silentAudioBuffer = window.globalAudioContext.createBuffer(1, 1, window.globalAudioContext.sampleRate);
              const silentSource = window.globalAudioContext.createBufferSource();
              silentSource.buffer = window.silentAudioBuffer;
              silentSource.connect(window.globalAudioContext.destination);
              silentSource.start(0);
              log('iOS: Буфер тишины воспроизведен');
            } catch (iosError) {
              log(`Ошибка буфера тишины: ${iosError.message}`, 'warn');
            }
          }

          if (isMobile && window.globalAudioContext.state !== 'running') {
            await window.globalAudioContext.resume();
          }

          window.audioInitialized = true;
          log('Инициализация аудио завершена успешно');
          return true;

        } catch (error) {
          log(`Ошибка инициализации аудио: ${error.message}`, 'error');
          return false;
        }
      }

      function playNextAudio() {
        if (audioPlaybackQueue.length === 0) {
          isPlayingAudio = false;
          interruptionState.is_assistant_speaking = false;
          sphere.classList.remove('speaking');
          stopAssistantVisualization();
          
          if (!isProcessingLLM) {
            setTimeout(() => {
              startListening();
            }, 400);
          }
          return;
        }
        
        isPlayingAudio = true;
        interruptionState.is_assistant_speaking = true;
        sphere.classList.add('speaking');
        sphere.classList.remove('listening', 'processing');
        
        const audioBase64 = audioPlaybackQueue.shift();
        
        try {
          const audioData = base64ToArrayBuffer(audioBase64);
          if (audioData.byteLength === 0) {
            playNextAudio();
            return;
          }
          
          const wavBuffer = createWavFromPcm(audioData);
          const blob = new Blob([wavBuffer], { type: 'audio/wav' });
          const audioUrl = URL.createObjectURL(blob);
          
          const audio = new Audio();
          audio.playsInline = true;
          audio.muted = false;
          audio.volume = 1.0;
          audio.preload = 'auto';
          audio.src = audioUrl;
          audio.crossOrigin = 'anonymous';
          
          interruptionState.current_audio_elements = interruptionState.current_audio_elements || [];
          interruptionState.current_audio_elements.push(audio);
          
          audio.oncanplay = function() {
            if (!interruptionState.is_assistant_speaking) {
              URL.revokeObjectURL(audioUrl);
              playNextAudio();
              return;
            }
            
            if (isIOS && window.globalAudioContext && window.globalAudioContext.state === 'suspended') {
              window.globalAudioContext.resume().then(() => {
                audio.play().then(() => {
                  startAssistantVisualization(audio);
                }).catch(err => {
                  log(`Ошибка воспроизведения: ${err.message}`, 'error');
                  URL.revokeObjectURL(audioUrl);
                  playNextAudio();
                });
              });
            } else {
              audio.play().then(() => {
                startAssistantVisualization(audio);
              }).catch(err => {
                log(`Ошибка воспроизведения: ${err.message}`, 'error');
                URL.revokeObjectURL(audioUrl);
                playNextAudio();
              });
            }
          };
          
          audio.onended = function() {
            URL.revokeObjectURL(audioUrl);
            const index = interruptionState.current_audio_elements.indexOf(audio);
            if (index > -1) {
              interruptionState.current_audio_elements.splice(index, 1);
            }
            playNextAudio();
          };
          
          audio.onerror = function() {
            URL.revokeObjectURL(audioUrl);
            playNextAudio();
          };
          
          audio.load();
          
        } catch (error) {
          log(`Ошибка создания аудио: ${error.message}`, 'error');
          playNextAudio();
        }
      }

      function addAudioToPlaybackQueue(audioBase64) {
        if (!audioBase64 || typeof audioBase64 !== 'string') return;
        
        audioPlaybackQueue.push(audioBase64);
        
        if (!isPlayingAudio) {
          playNextAudio();
        }
      }

      async function startListening() {
        if (!isConnected || isPlayingAudio || isReconnecting || isListening || isProcessingLLM) {
          log(`Не удается начать прослушивание: isConnected=${isConnected}, isPlayingAudio=${isPlayingAudio}, isReconnecting=${isReconnecting}, isListening=${isListening}, isProcessingLLM=${isProcessingLLM}`);
          return;
        }
        
        if (!window.audioInitialized || !window.globalAudioContext || !window.globalMicStream) {
          log('Аудио не инициализировано', 'warn');
          const success = await initializeAudio();
          if (!success) {
            log('Не удалось инициализировать аудио', 'error');
            return;
          }
        }
        
        isListening = true;
        log('Начинаем прослушивание');
        
        if (websocket && websocket.readyState === WebSocket.OPEN) {
          websocket.send(JSON.stringify({
            type: "input_audio_buffer.clear",
            event_id: `clear_${Date.now()}`
          }));
        }
        
        if (window.globalAudioContext.state === 'suspended') {
          try {
            await window.globalAudioContext.resume();
          } catch (error) {
            log(`Не удалось возобновить AudioContext: ${error}`, 'error');
            isListening = false;
            return;
          }
        }
        
        if (!audioProcessor) {
          const bufferSize = 2048;
          audioProcessor = window.globalAudioContext.createScriptProcessor(bufferSize, 1, 1);
          
          let isSilent = true;
          let silenceStartTime = Date.now();
          let lastCommitTime = 0;
          let hasSentAudioInCurrentSegment = false;
          
          audioProcessor.onaudioprocess = function(e) {
            if (isListening && websocket && websocket.readyState === WebSocket.OPEN && !isReconnecting) {
              const inputBuffer = e.inputBuffer;
              let inputData = inputBuffer.getChannelData(0);
              
              if (inputData.length === 0) return;
              
              let maxAmplitude = 0;
              for (let i = 0; i < inputData.length; i++) {
                maxAmplitude = Math.max(maxAmplitude, Math.abs(inputData[i]));
              }
              
              if (isMobile && AUDIO_CONFIG.amplificationFactor > 1.0) {
                const amplifiedData = new Float32Array(inputData.length);
                const gainFactor = AUDIO_CONFIG.amplificationFactor;
                
                for (let i = 0; i < inputData.length; i++) {
                  amplifiedData[i] = Math.max(-1.0, Math.min(1.0, inputData[i] * gainFactor));
                }
                
                inputData = amplifiedData;
                maxAmplitude = 0;
                for (let i = 0; i < inputData.length; i++) {
                  maxAmplitude = Math.max(maxAmplitude, Math.abs(inputData[i]));
                }
              }
              
              const hasSound = maxAmplitude > AUDIO_CONFIG.soundDetectionThreshold;
              updateCircularVisualization(inputData);
              
              const pcm16Data = new Int16Array(inputData.length);
              for (let i = 0; i < inputData.length; i++) {
                pcm16Data[i] = Math.max(-32768, Math.min(32767, Math.floor(inputData[i] * 32767)));
              }
              
              try {
                const message = JSON.stringify({
                  type: "input_audio_buffer.append",
                  event_id: `audio_${Date.now()}`,
                  audio: arrayBufferToBase64(pcm16Data.buffer)
                });
                
                websocket.send(message);
                hasSentAudioInCurrentSegment = true;
                
                if (!hasAudioData && hasSound) {
                  hasAudioData = true;
                  audioDataStartTime = Date.now();
                  log("Начало записи аудиоданных");
                }
                
              } catch (error) {
                log(`Ошибка отправки аудио: ${error.message}`, "error");
              }
              
              const now = Date.now();
              
              if (hasSound) {
                isSilent = false;
                silenceStartTime = now;
                
                if (!sphere.classList.contains('listening') && 
                    !sphere.classList.contains('speaking') &&
                    !sphere.classList.contains('processing')) {
                  sphere.classList.add('listening');
                }
              } else if (!isSilent) {
                const silenceDuration = now - silenceStartTime;
                
                if (silenceDuration > AUDIO_CONFIG.silenceDuration) {
                  isSilent = true;
                  
                  if (now - lastCommitTime > 1000 && hasSentAudioInCurrentSegment) {
                    setTimeout(() => {
                      if (isSilent && isListening && !isReconnecting) {
                        commitAudioBuffer();
                        lastCommitTime = Date.now();
                        hasSentAudioInCurrentSegment = false;
                      }
                    }, 100);
                  }
                }
              }
            }
          };
          
          const streamSource = window.globalAudioContext.createMediaStreamSource(window.globalMicStream);
          streamSource.connect(audioProcessor);
          
          const gainNode = window.globalAudioContext.createGain();
          gainNode.gain.value = 0;
          audioProcessor.connect(gainNode);
          gainNode.connect(window.globalAudioContext.destination);
        }
        
        hasAudioData = false;
        audioDataStartTime = 0;
        
        if (!isPlayingAudio && !isProcessingLLM) {
          sphere.classList.add('listening');
          sphere.classList.remove('speaking', 'processing');
        }
        
        log("Прослушивание начато успешно");
      }

      function commitAudioBuffer() {
        if (!isListening || !websocket || websocket.readyState !== WebSocket.OPEN || isReconnecting) return;
        
        if (!hasAudioData) {
          return;
        }
        
        const audioLength = Date.now() - audioDataStartTime;
        if (audioLength < minimumAudioLength) {
          setTimeout(() => {
            if (isListening && hasAudioData && !isReconnecting) {
              sendCommitBuffer();
            }
          }, minimumAudioLength - audioLength + 50);
          return;
        }
        
        sendCommitBuffer();
      }
      
      function sendCommitBuffer() {
        const audioLength = Date.now() - audioDataStartTime;
        if (audioLength < 100) {
          hasAudioData = false;
          audioDataStartTime = 0;
          return;
        }
        
        sphere.classList.remove('listening');
        
        websocket.send(JSON.stringify({
          type: "input_audio_buffer.commit",
          event_id: `commit_${Date.now()}`
        }));
        
        hasAudioData = false;
        audioDataStartTime = 0;
      }

      async function connectWebSocket() {
        try {
          loader.classList.add('active');
          log('Подключение...');
          
          isReconnecting = true;
          
          if (websocket) {
            try {
              websocket.close();
            } catch (e) {}
          }
          
          if (pingInterval) {
            clearInterval(pingInterval);
            pingInterval = null;
          }
          
          websocket = new WebSocket(WS_URL);
          websocket.binaryType = 'arraybuffer';
          
          websocket.onopen = function() {
            log('WebSocket подключен');
            isConnected = true;
            isReconnecting = false;
            reconnectAttempts = 0;
            loader.classList.remove('active');
            
            hudFrames.forEach(frame => frame.classList.add('active'));
            statusIndicator.classList.add('active');
            statusText.textContent = 'ПОДКЛЮЧЕНО';
            
            setTimeout(() => {
              startListening();
            }, 500);
            
            const pingIntervalTime = isMobile ? MOBILE_PING_INTERVAL : PING_INTERVAL;
            pingInterval = setInterval(() => {
              if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({ type: "ping" }));
              }
            }, pingIntervalTime);
          };
          
          websocket.onmessage = function(event) {
            try {
              if (event.data instanceof Blob || !event.data) return;

              try {
                const data = JSON.parse(event.data);
                lastPongTime = Date.now();
                
                // 🆕 LLM Event Handlers
                if (data.type === 'function_call.executing') {
                  handleFunctionExecuting(data);
                  return;
                }
                
                if (data.type === 'llm_result') {
                  handleLLMResult(data);
                  return;
                }
                
                if (data.type === 'function_call.completed') {
                  handleFunctionCompleted(data);
                  return;
                }
                
                // Original event handlers
                if (data.type === 'conversation.interrupted') {
                  handleInterruptionEvent(data);
                  return;
                }
                
                if (data.type === 'speech.started') {
                  handleSpeechStarted(data);
                  return;
                }
                
                if (data.type === 'speech.stopped') {
                  handleSpeechStopped(data);
                  return;
                }
                
                if (data.type === 'assistant.speech.started') {
                  handleAssistantSpeechStarted(data);
                  return;
                }
                
                if (data.type === 'assistant.speech.ended') {
                  handleAssistantSpeechEnded(data);
                  return;
                }
                
                if (data.type === 'response.cancelled') {
                  log('Ответ отменен');
                  stopAllAudioPlayback();
                  sphere.classList.remove('speaking', 'processing');
                  sphere.classList.add('interrupted');
                  
                  setTimeout(() => {
                    sphere.classList.remove('interrupted');
                    if (!interruptionState.is_assistant_speaking && !isProcessingLLM) {
                      switchToListeningMode();
                    }
                  }, 500);
                  return;
                }
                
                if (data.type === 'error') {
                  if (data.error && data.error.code === 'input_audio_buffer_commit_empty') {
                    if (!isPlayingAudio && !isReconnecting && !isProcessingLLM) {
                      setTimeout(() => { 
                        startListening(); 
                      }, 500);
                    }
                    return;
                  }
                  
                  log(`Ошибка API: ${JSON.stringify(data.error)}`, 'error');
                  return;
                }
                
                if (data.type === 'response.audio.delta') {
                  if (data.delta) {
                    audioChunksBuffer.push(data.delta);
                  }
                  return;
                }
                
                if (data.type === 'response.audio.done') {
                  if (audioChunksBuffer.length > 0) {
                    const fullAudio = audioChunksBuffer.join('');
                    addAudioToPlaybackQueue(fullAudio);
                    audioChunksBuffer = [];
                  }
                  return;
                }
                
                if (data.type === 'response.done') {
                  if (!isPlayingAudio && !isReconnecting && !isProcessingLLM) {
                    setTimeout(() => {
                      startListening();
                    }, 400);
                  }
                  return;
                }
                
              } catch (parseError) {
                if (event.data === 'pong') {
                  lastPongTime = Date.now();
                  return;
                }
              }
            } catch (generalError) {
              log(`Ошибка обработки: ${generalError.message}`, "error");
            }
          };
          
          websocket.onclose = function(event) {
            log(`WebSocket закрыт: ${event.code}`);
            isConnected = false;
            isListening = false;
            
            if (pingInterval) {
              clearInterval(pingInterval);
              pingInterval = null;
            }
            
            if (event.code === 1000 || event.code === 1001) {
              return;
            }
            
            const maxAttempts = isMobile ? MOBILE_MAX_RECONNECT_ATTEMPTS : MAX_RECONNECT_ATTEMPTS;
            if (reconnectAttempts < maxAttempts) {
              reconnectAttempts++;
              const delay = Math.min(30000, Math.pow(2, reconnectAttempts) * 1000);
              setTimeout(() => {
                connectWebSocket();
              }, delay);
            }
          };
          
          websocket.onerror = function(error) {
            log(`WebSocket ошибка: ${error}`, 'error');
          };
          
          return true;
          
        } catch (error) {
          log(`Ошибка подключения: ${error}`, 'error');
          isReconnecting = false;
          return false;
        }
      }

      powerButton.addEventListener('click', async function() {
        if (isActivated || !isSystemReady) return;
        
        isActivated = true;
        log('Активация ассистента...');
        
        powerButton.classList.add('activating');
        callText.classList.add('hidden');
        
        setTimeout(() => {
          powerButton.style.display = 'none';
          sphere.classList.add('active');
          loader.classList.add('active');
          initializeAndStart();
        }, 1500);
      });

      async function initializeAndStart() {
        const audioSuccess = await initializeAudio();
        if (!audioSuccess) {
          log('Не удалось инициализировать аудио', 'error');
          loader.querySelector('.voicyfy-loader-text').textContent = 'ОШИБКА ДОСТУПА К МИКРОФОНУ';
          setTimeout(() => {
            loader.classList.remove('active');
          }, 3000);
          return;
        }
        
        await connectWebSocket();
      }

      sphere.addEventListener('click', async function() {
        if (!window.audioInitialized) {
          log('Инициализация аудио по клику');
          const success = await initializeAudio();
          if (!success) {
            return;
          }
        }
        
        if (!isListening && !isPlayingAudio && !isReconnecting && !isProcessingLLM) {
          if (isConnected) {
            startListening();
          } else {
            connectWebSocket();
          }
        }
      });

      window.addEventListener('load', async function() {
        createCircularVisualizer();
        await bootSystem();
      });

    })();
  </script>
</body>
</html>
